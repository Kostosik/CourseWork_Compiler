//------------------------------------------------------------------------------
// <auto-generated>
//     Этот код создан программой.
//     Исполняемая версия:4.0.30319.42000
//
//     Изменения в этом файле могут привести к неправильной работе и будут потеряны в случае
//     повторной генерации кода.
// </auto-generated>
//------------------------------------------------------------------------------

namespace Compiler.Properties {
    using System;
    
    
    /// <summary>
    ///   Класс ресурса со строгой типизацией для поиска локализованных строк и т.д.
    /// </summary>
    // Этот класс создан автоматически классом StronglyTypedResourceBuilder
    // с помощью такого средства, как ResGen или Visual Studio.
    // Чтобы добавить или удалить член, измените файл .ResX и снова запустите ResGen
    // с параметром /str или перестройте свой проект VS.
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "17.0.0.0")]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    internal class Resources {
        
        private static global::System.Resources.ResourceManager resourceMan;
        
        private static global::System.Globalization.CultureInfo resourceCulture;
        
        [global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode")]
        internal Resources() {
        }
        
        /// <summary>
        ///   Возвращает кэшированный экземпляр ResourceManager, использованный этим классом.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Resources.ResourceManager ResourceManager {
            get {
                if (object.ReferenceEquals(resourceMan, null)) {
                    global::System.Resources.ResourceManager temp = new global::System.Resources.ResourceManager("Compiler.Properties.Resources", typeof(Resources).Assembly);
                    resourceMan = temp;
                }
                return resourceMan;
            }
        }
        
        /// <summary>
        ///   Перезаписывает свойство CurrentUICulture текущего потока для всех
        ///   обращений к ресурсу с помощью этого класса ресурса со строгой типизацией.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Globalization.CultureInfo Culture {
            get {
                return resourceCulture;
            }
            set {
                resourceCulture = value;
            }
        }
        
        /// <summary>
        ///   Поиск локализованного ресурса типа System.Drawing.Bitmap.
        /// </summary>
        internal static System.Drawing.Bitmap add {
            get {
                object obj = ResourceManager.GetObject("add", resourceCulture);
                return ((System.Drawing.Bitmap)(obj));
            }
        }
        
        /// <summary>
        ///   Поиск локализованного ресурса типа System.Drawing.Bitmap.
        /// </summary>
        internal static System.Drawing.Bitmap copy {
            get {
                object obj = ResourceManager.GetObject("copy", resourceCulture);
                return ((System.Drawing.Bitmap)(obj));
            }
        }
        
        /// <summary>
        ///   Поиск локализованного ресурса типа System.Drawing.Bitmap.
        /// </summary>
        internal static System.Drawing.Bitmap cut {
            get {
                object obj = ResourceManager.GetObject("cut", resourceCulture);
                return ((System.Drawing.Bitmap)(obj));
            }
        }
        
        /// <summary>
        ///   Ищет локализованную строку, похожую на &lt;!DOCTYPE html&gt;
        ///
        ///&lt;html lang=&quot;ru&quot;&gt;
        ///&lt;head&gt;
        ///    &lt;meta charset=&quot;utf-8&quot; /&gt;
        ///    &lt;title&gt;Диагностика и нейтрализация синтаксических ошибок&lt;/title&gt;
        ///&lt;/head&gt;
        ///&lt;body&gt;
        ///    &lt;h1&gt;
        ///        Диагностика и нейтрализация синтаксических ошибок
        ///    &lt;/h1&gt;
        ///    &lt;p&gt;
        ///        Для нашей программы необходимо реализовать нейтрализацию ошибок по методу и алгоритму Айронса. 
        ///    &lt;/p&gt;
        ///    &lt;h2&gt;Метод Айронса&lt;/h2&gt;
        ///    &lt;p&gt;
        ///        Суть метода Айронса заключается в следующем:&lt;br /&gt;
        ///        При обнаружении ошибки (во входной цепочк [остаток строки не уместился]&quot;;.
        /// </summary>
        internal static string DiagnosticsAndNeutralization {
            get {
                return ResourceManager.GetString("DiagnosticsAndNeutralization", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Ищет локализованную строку, похожую на &lt;!DOCTYPE html&gt;
        ///
        ///&lt;html lang=&quot;ru&quot;&gt;
        ///&lt;head&gt;
        ///    &lt;meta charset=&quot;utf-8&quot; /&gt;
        ///    &lt;title&gt;Тестовые примеры&lt;/title&gt;
        ///&lt;/head&gt;
        ///&lt;body&gt;
        ///    &lt;h1&gt;
        ///        Тестовые примеры
        ///    &lt;/h1&gt;
        ///    &lt;p&gt;
        ///        На рисунках 2-6 представлены тестовые примеры запуска разработанного синтаксического анализатора ассоциативного массива на языке C#.
        ///    &lt;/p&gt;
        ///
        ///    &lt;img src=&quot;ex1.png&quot; alt=&quot;&quot;&gt;
        ///    &lt;p&gt;
        ///        Рисунок 2 – Тестовый пример 1&lt;br /&gt;
        ///    &lt;/p&gt;
        ///    &lt;img src=&quot;ex2.png&quot; alt=&quot;&quot;&gt;
        ///    &lt;p&gt;
        ///        Рисунок 3 – Тестовый пример  [остаток строки не уместился]&quot;;.
        /// </summary>
        internal static string Examples {
            get {
                return ResourceManager.GetString("Examples", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Поиск локализованного ресурса типа System.Drawing.Bitmap.
        /// </summary>
        internal static System.Drawing.Bitmap folder {
            get {
                object obj = ResourceManager.GetObject("folder", resourceCulture);
                return ((System.Drawing.Bitmap)(obj));
            }
        }
        
        /// <summary>
        ///   Ищет локализованную строку, похожую на &lt;!DOCTYPE html&gt;
        ///
        ///&lt;html lang=&quot;ru&quot;&gt;
        ///&lt;head&gt;
        ///    &lt;meta charset=&quot;utf-8&quot; /&gt;
        ///    &lt;title&gt;Грамматика&lt;/title&gt;
        ///&lt;/head&gt;
        ///&lt;body style=&quot;font-family: &apos;Times New Roman&apos;, Times, serif; font-size: 20px;&quot;&gt;
        ///    &lt;h1&gt;
        ///        Грамматика
        ///    &lt;/h1&gt;
        ///    &lt;p&gt;
        ///        Определим грамматику для объявления целочисленной константы с инициализацией на языке Kotlin G[‹Def›] в нотации Хомского с продукциями P:
        ///    &lt;/p&gt;
        ///    &lt;p&gt;
        ///        &lt;p&gt;1. &amp;lt;DEF&amp;gt; -&gt; &apos;const&apos; &amp;lt;CONST&amp;gt;&lt;br /&gt;&lt;/p&gt;
        ///        &lt;p&gt;2. &amp;lt;CONST&amp;gt; -&gt; &apos;val&apos; &amp;lt [остаток строки не уместился]&quot;;.
        /// </summary>
        internal static string Grammar {
            get {
                return ResourceManager.GetString("Grammar", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Ищет локализованную строку, похожую на &lt;!DOCTYPE html&gt;
        ///
        ///&lt;html lang=&quot;ru&quot;&gt;
        ///&lt;head&gt;
        ///    &lt;meta charset=&quot;utf-8&quot; /&gt;
        ///    &lt;title&gt;Классификация грамматики&lt;/title&gt;
        ///&lt;/head&gt;
        ///&lt;body&gt;
        ///    &lt;h1&gt;
        ///        Классификация грамматики
        ///    &lt;/h1&gt;
        ///   &lt;p&gt; Н. Хомский выделил четыре класса грамматик: грамматики нулевого типа, контекстно-зависимые, контекстно-свободные и автоматные грамматики.&lt;br /&gt;
        ///     Вид грамматики определяется исходя из формы записи ее правил.&lt;br /&gt;
        ///Грамматики нулевого типа имеют правила следующего вида:&lt;/p&gt;
        ///α→β,&lt;br /&gt;
        ///где α ∈ V*, V = Vт ⋃  [остаток строки не уместился]&quot;;.
        /// </summary>
        internal static string GrammarClassification {
            get {
                return ResourceManager.GetString("GrammarClassification", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Поиск локализованного ресурса типа System.Drawing.Bitmap.
        /// </summary>
        internal static System.Drawing.Bitmap info {
            get {
                object obj = ResourceManager.GetObject("info", resourceCulture);
                return ((System.Drawing.Bitmap)(obj));
            }
        }
        
        /// <summary>
        ///   Поиск локализованного ресурса типа System.Drawing.Bitmap.
        /// </summary>
        internal static System.Drawing.Bitmap left_arrow {
            get {
                object obj = ResourceManager.GetObject("left-arrow", resourceCulture);
                return ((System.Drawing.Bitmap)(obj));
            }
        }
        
        /// <summary>
        ///   Ищет локализованную строку, похожую на &lt;!DOCTYPE html&gt;
        ///
        ///&lt;html lang=&quot;ru&quot;&gt;
        ///&lt;head&gt;
        ///    &lt;meta charset=&quot;utf-8&quot; /&gt;
        ///    &lt;title&gt;Список литературы&lt;/title&gt;
        ///&lt;/head&gt;
        ///&lt;body&gt;
        ///    &lt;h1&gt;
        ///        Список литературы
        ///    &lt;/h1&gt;
        ///    &lt;p&gt;
        ///        1. Шорников Ю.В. Теория и практика языковых процессоров : учеб. пособие / Ю.В. Шорников. – Новосибирск: Изд-во НГТУ, 2022.&lt;br /&gt;
        ///        2. Gries D. Designing Compilers for Digital Computers. New York, Jhon Wiley, 1971. 493 p.&lt;br /&gt;
        ///        3. Теория формальных языков и компиляторов [Электронный ресурс] / Электрон [остаток строки не уместился]&quot;;.
        /// </summary>
        internal static string Literature {
            get {
                return ResourceManager.GetString("Literature", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Ищет локализованную строку, похожую на &lt;!DOCTYPE html&gt;
        ///
        ///&lt;html lang=&quot;ru&quot;&gt;
        ///&lt;head&gt;
        ///    &lt;meta charset=&quot;utf-8&quot; /&gt;
        ///    &lt;title&gt;Метод анализа&lt;/title&gt;
        ///&lt;/head&gt;
        ///&lt;body&gt;
        ///    &lt;h1&gt;
        ///        Метод анализа
        ///    &lt;/h1&gt;
        ///    &lt;p&gt;
        ///        Для анализа грамматики было выбрано её представление в виде графа конечного автомата (рис. 1),&lt;br /&gt;
        ///         где состояние 0 – является начальным, а состояние 8 – конечным.&lt;br /&gt;
        ///    &lt;/p&gt;
        ///    &lt;img src=&quot;graph.png&quot; alt=&quot;&quot;&gt;
        ///    &lt;p&gt;
        ///        Рисунок 1 – Граф конечного автомата грамматики G[‹DEF›]
        ///    &lt;/p&gt;
        ///&lt;/body&gt;
        ///&lt;/html [остаток строки не уместился]&quot;;.
        /// </summary>
        internal static string MethodOfAnalisys {
            get {
                return ResourceManager.GetString("MethodOfAnalisys", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Поиск локализованного ресурса типа System.Drawing.Bitmap.
        /// </summary>
        internal static System.Drawing.Bitmap paste {
            get {
                object obj = ResourceManager.GetObject("paste", resourceCulture);
                return ((System.Drawing.Bitmap)(obj));
            }
        }
        
        /// <summary>
        ///   Поиск локализованного ресурса типа System.Drawing.Bitmap.
        /// </summary>
        internal static System.Drawing.Bitmap question_mark {
            get {
                object obj = ResourceManager.GetObject("question-mark", resourceCulture);
                return ((System.Drawing.Bitmap)(obj));
            }
        }
        
        /// <summary>
        ///   Поиск локализованного ресурса типа System.Drawing.Bitmap.
        /// </summary>
        internal static System.Drawing.Bitmap right_arrow {
            get {
                object obj = ResourceManager.GetObject("right-arrow", resourceCulture);
                return ((System.Drawing.Bitmap)(obj));
            }
        }
        
        /// <summary>
        ///   Поиск локализованного ресурса типа System.Drawing.Bitmap.
        /// </summary>
        internal static System.Drawing.Bitmap run {
            get {
                object obj = ResourceManager.GetObject("run", resourceCulture);
                return ((System.Drawing.Bitmap)(obj));
            }
        }
        
        /// <summary>
        ///   Поиск локализованного ресурса типа System.Drawing.Bitmap.
        /// </summary>
        internal static System.Drawing.Bitmap save {
            get {
                object obj = ResourceManager.GetObject("save", resourceCulture);
                return ((System.Drawing.Bitmap)(obj));
            }
        }
        
        /// <summary>
        ///   Ищет локализованную строку, похожую на &lt;!DOCTYPE html&gt;
        ///
        ///&lt;html lang=&quot;ru&quot;&quot;&gt;
        ///&lt;head&gt;
        ///    &lt;meta charset=&quot;utf-8&quot; /&gt;
        ///    &lt;title&gt;Постановка задачи&lt;/title&gt;
        ///&lt;/head&gt;
        ///&lt;body&gt;
        ///    &lt;h1&gt;
        ///        Постановка задачи
        ///    &lt;/h1&gt;
        ///    &lt;pre style=&quot;font-family: &apos;Times New Roman&apos;, Times, serif; font-size: 20px;&quot;&gt;
        ///Целочисленная константа с инициализацией на языке Kotlin — это значение, которое представляет собой целое число и назначается переменной при её создании. 
        ///Она позволяет задать начальное значение переменной сразу после её объявления.
        ///Формат записи:         /// [остаток строки не уместился]&quot;;.
        /// </summary>
        internal static string Task {
            get {
                return ResourceManager.GetString("Task", resourceCulture);
            }
        }
    }
}
